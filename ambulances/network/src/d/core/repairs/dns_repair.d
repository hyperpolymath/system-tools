// SPDX-License-Identifier: PMPL-1.0-or-later
/**
 * DNS repair module
 */
module core.repairs.dns_repair;

import platform;
import core.diagnostics.dns;
import std.file;
import std.path;
import std.datetime.systime;
import std.format;
import std.algorithm;
import std.array;

/// DNS repair result
struct DNSRepairResult {
    bool success;
    bool backupCreated;
    string backupPath;
    string[] actions;
    string[] errors;
}

/// Public DNS servers to use as fallbacks
immutable string[] PUBLIC_DNS_SERVERS = [
    "8.8.8.8",      // Google DNS
    "1.1.1.1",      // Cloudflare DNS
    "9.9.9.9",      // Quad9 DNS
    "8.8.4.4",      // Google DNS secondary
];

/// Repair DNS configuration
DNSRepairResult repairDNS(NetworkPlatform platform, DNSDiagnostics diag) @safe {
    DNSRepairResult result;

    // Check if repair is needed
    if (diag.canResolve && diag.hasDNSServers) {
        result.success = true;
        result.actions ~= "DNS is working correctly, no repair needed";
        return result;
    }

    // Backup current configuration
    result.backupPath = backupResolvConf();
    result.backupCreated = result.backupPath.length > 0;

    if (!result.backupCreated) {
        result.errors ~= "Failed to create backup of /etc/resolv.conf";
        result.success = false;
        return result;
    }

    result.actions ~= format("Backed up /etc/resolv.conf to %s", result.backupPath);

    // Determine which servers to add
    string[] serversToAdd;

    if (!diag.hasDNSServers) {
        // No servers configured - add all public DNS
        serversToAdd = PUBLIC_DNS_SERVERS.dup;
        result.actions ~= "No DNS servers configured";
    } else {
        // Some servers exist but aren't working - add working public DNS
        auto workingServers = diag.servers.filter!(s => s.reachable);

        if (workingServers.empty) {
            serversToAdd = PUBLIC_DNS_SERVERS.dup;
            result.actions ~= "All configured DNS servers unreachable";
        } else {
            // Add just the first two public DNS as backups
            serversToAdd = PUBLIC_DNS_SERVERS[0..2].dup;
            result.actions ~= "Adding backup DNS servers";
        }
    }

    // Write new resolv.conf
    try {
        auto content = generateResolvConf(serversToAdd);
        std.file.write("/etc/resolv.conf", content);

        foreach (server; serversToAdd) {
            result.actions ~= format("Added DNS server: %s", server);
        }

        // Verify repair worked
        auto newDiag = diagnoseDNS(platform);
        if (newDiag.canResolve) {
            result.success = true;
            result.actions ~= "DNS repair successful, resolution working";
        } else {
            // Rollback
            rollbackResolvConf(result.backupPath);
            result.errors ~= "DNS repair failed, rolled back to original configuration";
            result.success = false;
        }

    } catch (Exception e) {
        result.errors ~= format("Failed to write /etc/resolv.conf: %s", e.msg);

        // Attempt rollback
        try {
            rollbackResolvConf(result.backupPath);
            result.actions ~= "Rolled back to original configuration";
        } catch (Exception rollbackE) {
            result.errors ~= format("Rollback failed: %s", rollbackE.msg);
        }

        result.success = false;
    }

    return result;
}

/// Generate resolv.conf content
string generateResolvConf(string[] servers) pure @safe {
    string content = "# Generated by Network Ambulance\n";
    content ~= "# Original backed up with timestamp\n\n";

    foreach (server; servers) {
        content ~= format("nameserver %s\n", server);
    }

    content ~= "\noptions timeout:2 attempts:3\n";

    return content;
}

/// Backup /etc/resolv.conf with timestamp
string backupResolvConf() @trusted {
    immutable string resolvConfPath = "/etc/resolv.conf";

    if (!exists(resolvConfPath)) {
        return "";
    }

    try {
        auto now = Clock.currTime();
        auto timestamp = format("%04d%02d%02d_%02d%02d%02d",
                               now.year, now.month, now.day,
                               now.hour, now.minute, now.second);

        string backupPath = format("/etc/resolv.conf.backup.%s", timestamp);

        copy(resolvConfPath, backupPath);
        return backupPath;

    } catch (Exception e) {
        return "";
    }
}

/// Rollback to backed up resolv.conf
void rollbackResolvConf(string backupPath) @trusted {
    if (backupPath.length == 0 || !exists(backupPath)) {
        return;
    }

    copy(backupPath, "/etc/resolv.conf");
}

/// Remove old backup files (keep last 5)
void cleanupOldBackups() @trusted {
    import std.file : dirEntries, SpanMode, remove;

    try {
        auto backups = dirEntries("/etc", "resolv.conf.backup.*", SpanMode.shallow)
            .array
            .sort!((a, b) => a.timeLastModified > b.timeLastModified)
            .array;

        // Keep last 5, delete rest
        if (backups.length > 5) {
            foreach (backup; backups[5..$]) {
                remove(backup.name);
            }
        }
    } catch (Exception e) {
        // Silently fail - cleanup is not critical
    }
}
